---
title: 3주차 복습
date: 2023-10-10 00:10:18
category: 함수형프로그래밍
thumbnail: { thumbnailSrc }
draft: false
---

### range

```js
const range = l => {
  let i = -1
  let res = []
  while (++i < l) {
    res.push(i)
  }
  return res
}

var list = L.range(4)
log(list) // 배열 [0, 1, 2, 3]
log(reduce(add, list)) // 6
```

- 배열이 반환됨

### 느긋한 L.range

```js
const L = {}
L.range = function*(l) {
  let i = -1
  while (++i < l) {
    log(i, 'L.range')
    yield i
  }
}

var list = L.range(4)
log(list) // 이터레이터 객체
log(reduce(add, list)) // 6
```

- 완성된 배열이 리턴되는 것이 아닌, next()함수 등을 가지는 이터레이터 객체가 반환된다.

### 둘의 효율성 차이?

- 완성된 배열을 만들고 순회하는 range와 이터레이터를 순회하면서 처리하는 L.range를 비교하면 L.range가 좀더 효율적이다.

### take 함수

```js
const take = (l, iter) => {
  let res = []
  for (const a of iter) {
    res.push(a)
    if (res.length == l) return res
  }
  return res
}
console.log(take(5, range(100000)))
console.log(take(5, L.range(100000)))
```

- 순회하면서 자르는 L.range가 더 효율적이다.
- 필요한 만큼만 순회함.

### 이터러블 중심 프로그래밍의 지연 평가 (Lazy Evaluation)

- 제때 계산법
- 느긋한 계산법
- 제너레이터/이터레이터 프로토콜을 기반으로 구현

### L.map

```js
const L = {}
L.map = function*(f, iter) {
  for (const a of iter) yield f(a)
}
```

- 지연성을 가진 map 함수

### L.filter

```js
const L = {}
L.filter = function*(f, iter) {
  for (const a of iter) if (f(a)) yield a
}
```

- 지연성을 가진 filter 함수
