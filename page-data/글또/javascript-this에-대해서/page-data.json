{"componentChunkName":"component---src-templates-blog-post-js","path":"/글또/javascript-this에-대해서/","result":{"data":{"site":{"siteMetadata":{"title":"Easyone의 기술블로그","author":"thinkanddoit","siteUrl":"https://thinkanddoit.github.io","comment":{"disqusShortName":"","utterances":"thinkanddoit/thinkanddoit.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"54dc1385-f82a-594a-936a-c2ad68ef4d56","excerpt":"요약: JavaScript에서 함수는 호출될 때, 매개변수로 전달되는 인자값 이외에, arguments 객체와 this를 암묵적으로 전달 받는다. this는 함수 호출 방식에 따라 바인딩되는 객체가 달라진다. 자바스크립트에서는 함수 호출 방식에 따라 동적으로 결정되는 객체가 this에 바인딩된다. 1. 함수 호출 전역 객체는 모든 객체의 최상위 객체를 의미하며, 클라이언트 측에서는 window, 서버 측에서는 global…","html":"<p>요약:</p>\n<blockquote>\n<p>JavaScript에서 함수는 호출될 때, 매개변수로 전달되는 인자값 이외에, arguments 객체와 this를 암묵적으로 전달 받는다. this는 함수 호출 방식에 따라 바인딩되는 객체가 달라진다.</p>\n</blockquote>\n<h4 id=\"자바스크립트에서는-함수-호출-방식에-따라-동적으로-결정되는-객체가-this에-바인딩된다\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C%EB%8A%94-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C-%EB%B0%A9%EC%8B%9D%EC%97%90-%EB%94%B0%EB%9D%BC-%EB%8F%99%EC%A0%81%EC%9C%BC%EB%A1%9C-%EA%B2%B0%EC%A0%95%EB%90%98%EB%8A%94-%EA%B0%9D%EC%B2%B4%EA%B0%80-this%EC%97%90-%EB%B0%94%EC%9D%B8%EB%94%A9%EB%90%9C%EB%8B%A4\" aria-label=\"자바스크립트에서는 함수 호출 방식에 따라 동적으로 결정되는 객체가 this에 바인딩된다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바스크립트에서는 함수 호출 방식에 따라 동적으로 결정되는 객체가 this에 바인딩된다.</h4>\n<h3 id=\"1-함수-호출\" style=\"position:relative;\"><a href=\"#1-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C\" aria-label=\"1 함수 호출 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 함수 호출</h3>\n<ul>\n<li>전역 객체는 모든 객체의 최상위 객체를 의미하며, 클라이언트 측에서는 window, 서버 측에서는 global 객체를 의미한다.</li>\n<li>전역 영역에 선언한 함수는 전역 변수의 메소드로 동작한다. 이때 this는 전역 객체에 바인딩된다.</li>\n<li>내부 함수, 메소드, 콜백 함수에서도 this는 전역 객체에 바인딩된다.</li>\n<li>더글라스 크락포드는 이를 “설계 단계의 결함”으로 설명하며, 메소드가 내부 함수를 사용하여 자신의 작업을 직접 돕게 할 수 없다는 것을 의미한다.</li>\n<li>일반적으로 내부 함수(특히 콜백 함수)의 this가 전역 객체를 참조하는 것을 회피하기 위해 다음과 같은 방법을 사용한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> _this <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>_this<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>또한, JavaScript는 apply, call, bind 메소드를 사용하여 명시적으로 this를 바인딩하는 방법을 제공한다.</p>\n<h3 id=\"2-메소드-호출\" style=\"position:relative;\"><a href=\"#2-%EB%A9%94%EC%86%8C%EB%93%9C-%ED%98%B8%EC%B6%9C\" aria-label=\"2 메소드 호출 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 메소드 호출</h3>\n<ul>\n<li>메소드는 해당 메소드를 호출한 객체에 대해 this가 바인딩된다.</li>\n</ul>\n<h3 id=\"3-생성자-함수-호출\" style=\"position:relative;\"><a href=\"#3-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C\" aria-label=\"3 생성자 함수 호출 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 생성자 함수 호출</h3>\n<ul>\n<li>new 연산자와 함께 생성자 함수를 호출하는 경우, this 바인딩이 일반 함수나 메소드 호출 때와는 다르게 동작한다.</li>\n</ul>\n<p>빈 객체 생성 및 this 바인딩:</p>\n<p>생성자 함수의 코드 실행 전에 빈 객체가 생성되고, 이후 생성자 함수 내에서 사용되는 this는 이 빈 객체를 가리킨다.\n생성된 빈 객체는 생성자 함수의 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다.\nthis를 통한 프로퍼티 생성:</p>\n<p>빈 객체에 this를 사용하여 동적으로 프로퍼티와 메소드를 생성할 수 있다. 이때 this는 생성 중인 빈 객체를 가리킨다.\n생성된 객체 반환:</p>\n<p>반환문이 없는 경우, this에 바인딩된 새로 생성된 객체가 반환된다 (빈 객체).\n반환문으로 this가 아닌 다른 객체를 명시적으로 반환할 수도 있다. 일반적으로 생성자 함수는 반환문을 명시적으로 사용하지 않는다.\n참고: 객체 리터럴과 생성자 함수의 차이는 프로토타입 객체에 있다. 객체 리터럴의 프로토타입 객체는 Object.prototype이고, 생성자 함수의 프로토타입 객체는 생성자 함수의 prototype이다.</p>\n<p>다음 포스팅에서는 apply, call, bind 호출에 대해 자세히 알아보겠다.</p>\n<p>출처: <a href=\"https://poiemaweb.com/js-this\">https://poiemaweb.com/js-this</a></p>","frontmatter":{"title":"JavaScript this에 대해서","date":"May 21, 2023"}}},"pageContext":{"slug":"/글또/javascript-this에-대해서/","previous":{"fields":{"slug":"/글또/ssr과-csr/"},"frontmatter":{"title":"SSR과 CSR"}},"next":{"fields":{"slug":"/글또/csr-vs-ssr-vs-ssg-차이-정리/"},"frontmatter":{"title":"CSR vs SSR vs SSG 차이 정리"}}}}}