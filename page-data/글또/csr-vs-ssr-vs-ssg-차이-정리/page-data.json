{"componentChunkName":"component---src-templates-blog-post-js","path":"/글또/csr-vs-ssr-vs-ssg-차이-정리/","result":{"data":{"site":{"siteMetadata":{"title":"Easyone의 기술블로그","author":"thinkanddoit","siteUrl":"https://thinkanddoit.github.io","comment":{"disqusShortName":"","utterances":"thinkanddoit/thinkanddoit.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"5f0dc352-072c-5982-84c9-6031c761680b","excerpt":"CSR vs SSR vs SSG 정리하기 CSR vs SSR vs SSG 웹 페이지를 렌더링하는방식 Client Side Rendering (CSR) 클라이언트(브라우저)에서 웹 페이지를 렌더링 하는 것. TTI === TTV 모든 로직, 데이터 가져오기, 템플릿, 라우팅은 서버가 아닌 클라이언트에서 처리 CSR은 js번들 크기의 영향을 많이 받아서 적극적  을 고려해야한다. (FCP최적화, TTI최적화) *FCP(First Contentful Paint) - 첫 유용한 콘텐츠 *FP(First…","html":"<p><a href=\"https://ajdkfl6445.gitbook.io/study/web/csr-vs-ssr-vs-ssg\">CSR vs SSR vs SSG</a></p>\n<p>정리하기</p>\n<h2 id=\"csr-vs-ssr-vs-ssg\" style=\"position:relative;\"><a href=\"#csr-vs-ssr-vs-ssg\" aria-label=\"csr vs ssr vs ssg permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CSR vs SSR vs SSG</h2>\n<ul>\n<li>웹 페이지를 렌더링하는방식</li>\n</ul>\n<h3 id=\"client-side-rendering-csr\" style=\"position:relative;\"><a href=\"#client-side-rendering-csr\" aria-label=\"client side rendering csr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Client Side Rendering (CSR)</h3>\n<ul>\n<li>클라이언트(브라우저)에서 웹 페이지를 렌더링 하는 것.</li>\n<li>TTI === TTV</li>\n<li>모든 로직, 데이터 가져오기, 템플릿, 라우팅은 서버가 아닌 클라이언트에서 처리</li>\n</ul>\n<blockquote>\n<p>CSR은 js번들 크기의 영향을 많이 받아서 적극적 <code class=\"language-text\">code splitting</code> 을 고려해야한다. (FCP최적화, TTI최적화)</p>\n</blockquote>\n<p>*FCP(First Contentful Paint) - 첫 유용한 콘텐츠</p>\n<p>*FP(First Paint) - 첫 픽셀</p>\n<p>*TTI(Time to Interactive)</p>\n<p>*TTV(Time to View)</p>\n<p><strong>CSR 동작 방식</strong></p>\n<ol>\n<li>사용자의 웹 페이지 방문 (request)</li>\n<li>\n<p>브라우저는 최소한 HTML 파일을 다운로드 (response)</p>\n<ul>\n<li>최소한 HTML(index.html)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token doctype\"><span class=\"token punctuation\">&lt;!</span><span class=\"token doctype-tag\">DOCTYPE</span> <span class=\"token name\">html</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>html</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>head</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n  &lt;!-- 페이지에 필요한 외부 스타일시트, 스크립트 등의 리소스를 로드하기 위한 태그 -->\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>link</span> <span class=\"token attr-name\">rel</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>stylesheet<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">href</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>styles.css<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>main.js<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>head</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>body</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n  &lt;!-- 초기에 빈 콘텐츠를 가지고 있을 수도 있습니다. -->\n\n  &lt;!-- JavaScript와 데이터를 이용하여 동적으로 콘텐츠를 생성하는 영역 -->\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    // JavaScript 코드\n    // 데이터 로딩 및 콘텐츠 생성 로직\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>body</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>html</span><span class=\"token punctuation\">></span></span></code></pre></div>\n</li>\n<li>브라우저는 <code class=\"language-text\">index.html</code>에 있는 js 번들 파일을 다운로드</li>\n<li><code class=\"language-text\">AJAX</code> 를 통해 <code class=\"language-text\">API</code> 요청을 수행해 동적 컨텐츠를 가져오고 파싱 → 최종 컨텐츠 렌더링</li>\n<li>사용자가 페이지를 이동하는 경우, 서버에 추가 <code class=\"language-text\">HTML</code> 파일 요청 없이 이미 받은 자바스크립트를 이용해 렌더링</li>\n</ol>\n<p><strong>CSR 장점</strong></p>\n<ul>\n<li>후속 페이지 로드 시간이 빠름 (이미 모든 스크립트가 사전 로드)</li>\n<li>서버 부하 감소</li>\n<li>서버 호출시 전체 UI 다시 로드할 필요 없음</li>\n</ul>\n<p><strong>CSR 단점</strong></p>\n<ul>\n<li>초기 페이지 로드가 <code class=\"language-text\">SSR</code> 에 비해 느림</li>\n<li>\n<p>SEO에 친화적이지 않음 (검색 엔진 크롤러 방문시 빈 페이지)</p>\n<ul>\n<li>구글 크롤러는 js실행 시키긴 하지만 모든 검색엔진크롤러가 지원하지 않음</li>\n</ul>\n</li>\n<li>처음 HTML, JavaScript 파일 다운, 프레임워크 실행시점에 사용자가 빈 페이지를 봄</li>\n</ul>\n<h3 id=\"server-side-rendering-ssr\" style=\"position:relative;\"><a href=\"#server-side-rendering-ssr\" aria-label=\"server side rendering ssr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Server Side Rendering (SSR)</h3>\n<ul>\n<li>서버의 <code class=\"language-text\">HTML</code> 로 렌더링하는 방식</li>\n<li>TTV >>> TTI</li>\n<li>브라우저에서 응답 받기 전 데이터 패칭 및 템플릿 작성이 처리됨</li>\n</ul>\n<p><strong>SSR 동작 방식</strong></p>\n<ol>\n<li>사용자의 웹 페이지 방문 (request)</li>\n<li>서버는 리소스 확인, 페이지 내 서버측 스크립트 실행 후 <code class=\"language-text\">HTML</code> 컨텐츠를 컴파일 및 준비</li>\n<li>컴파일된 <code class=\"language-text\">HTML</code>은 추가 렌더링 및 표시를 위해 클라이언트(브라우저)로 전송(response)</li>\n<li>브라우저는 <code class=\"language-text\">HTML</code>을 다운하고 사용자가 사이트를 볼 수 있게 함</li>\n<li>브라우저는 자바스크립트를 다운로드하고 실행하면서 <code class=\"language-text\">interactive</code>하게함</li>\n<li>사용자가 페이지를 이동할 때마다 위 동작 반복</li>\n</ol>\n<p><strong>SSR 장점</strong></p>\n<ul>\n<li>초기 페이지 로드시간이 빠름(<code class=\"language-text\">FP</code> 및 <code class=\"language-text\">FCP</code>가 빠르다)</li>\n<li>이미 렌더링이 준비된 <code class=\"language-text\">HTML</code> 파일을 브라우저에서 로드하기 때문에 CSR에 비해 빠름</li>\n<li>서버에서 페이지 로직 및 렌더링을 실행하면서 Js를 클라이언트에 보내지 않아도 됨으로 <code class=\"language-text\">TTI</code>를 빠르게 수행할 수 있다.</li>\n<li><code class=\"language-text\">SEO</code>에 친화적이다.</li>\n</ul>\n<p><strong>SSR 단점</strong></p>\n<ul>\n<li>\n<p>페이지 이동시마다 서버에서 페이지를 생성하는데 시간이 걸리기때문에 <code class=\"language-text\">TTFB</code>가 느리다.</p>\n<ul>\n<li>TTFB(Time to First Byte)</li>\n<li>요청 후 첫 바이트 수신 시간</li>\n<li>CSR은 최소한의 <code class=\"language-text\">HTML</code>을 받기에 <code class=\"language-text\">TTFP</code>가 상대적으로 낮음</li>\n</ul>\n</li>\n<li>서버 호스팅이 필요하다</li>\n<li>CSR에 비해 더 많은 개발 노력이 필요, SSR 프레임워크 사용시 추가 러닝 커브 비용 발생</li>\n</ul>\n<h3 id=\"static-site-generatorssg\" style=\"position:relative;\"><a href=\"#static-site-generatorssg\" aria-label=\"static site generatorssg permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Static Site Generator(SSG)</h3>\n<ul>\n<li>SSR처럼 서버로 부터 완성된 HTML을 받아옴.</li>\n<li>차이는 HTML 파일의 생성시점이 빌드타임이다.</li>\n<li>Static이라는 용어는 HTML이 정적이라는 것이지 페이지가 정적인 것은 아님</li>\n<li>Next.js에서 권장하는 렌더링 방식</li>\n</ul>\n<p><strong>SSG 동작 방식</strong></p>\n<ol>\n<li>사용자의 웹 페이지 방문 (request)</li>\n<li>엣지 캐싱(edge caching)된 HTML을 클라이언트로 반환</li>\n<li>브라우저는 HTML을 다운로드하고 최종 사용자가 사이트를 보게함</li>\n</ol>\n<blockquote>\n<p>엣지 캐싱(edge caching)?\n사용자에게 더 가까운 컨텐츠를 저장하기 위해 캐싱 서버를 사용하는 것\n대표 : CDN</p>\n</blockquote>\n<p><strong>SSG 장점</strong></p>\n<ul>\n<li>빌드타임에 HTML 파일이 생성되기 때문에 빠른 FP,FCP,TTI를 제공</li>\n<li>매 요청마다 생성하는 것이 아니므로, SSR과 달리 일관성 있게 빠른 TFB달성</li>\n<li>이미 생성된 HTML파일을 받아서 SEO에 친화적</li>\n</ul>\n<p><strong>SSG 단점</strong></p>\n<ul>\n<li>모든 URL에 대해 개별 HTML 파일을 생성해야한다.</li>\n<li>URL을 미리 예측할 수 없으면 적용이 어려움</li>\n</ul>\n<p><strong>SSR vs SSG</strong></p>\n<ul>\n<li>SSR은 SSG에서 가능한 것보다 더 많은 “실시간”데이터를 가져와 보다 완전한 요청에 대한 응답을 하는 것이다.</li>\n<li>속도는 SSG가 빠름.</li>\n<li>따라서 필요한 경우에만 SSR을 사용</li>\n</ul>\n<h3 id=\"universal-rendering\" style=\"position:relative;\"><a href=\"#universal-rendering\" aria-label=\"universal rendering permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Universal Rendering</h3>\n<ul>\n<li>SSR을 통해 빠른 FCP를 구현한 다음 클라이언트에서 rehydration이라는 기술을 통해 다시 렌더링하는 방식.</li>\n<li>초기로딩시 SSR / 그 이후에 CSR로 작동</li>\n</ul>\n<p><strong>Universal Rendering 장점</strong></p>\n<ul>\n<li>SSR을 통해 빠른 FCP를 구현함으로 CSR의 단점 개선</li>\n</ul>\n<p><strong>Universal Rendering 단점</strong></p>\n<ul>\n<li>별도의 서버 필요, 러닝커버 비용 큼</li>\n</ul>\n<h3 id=\"incremental-static-regeneration-isr\" style=\"position:relative;\"><a href=\"#incremental-static-regeneration-isr\" aria-label=\"incremental static regeneration isr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Incremental Static Regeneration (ISR)</h3>\n<ul>\n<li>런타임 중에 정적 페이지를 만들거나 업데이트 할 수 있도록 해주는 SSG와 SSR의 하이브리드 솔루션</li>\n<li>Next.js에서 제공하는 기능이기도 하며, 전체 사이트를 다시 빌드할 필요없이 페이지별로 정적생성 사용가능하게 해줌</li>\n</ul>\n<p><strong>ISR 동작 방식</strong></p>\n<ol>\n<li>사용자의 웹 페이지 방문 (request)</li>\n<li>\n<p>요청에 의해 페이지가 npm생성되지만 SSR과 달리 즉시 대체 페이지(fallback page)가 제공됨</p>\n<ol>\n<li>placeholder 및 스캘래톤 표시</li>\n</ol>\n</li>\n<li>데이터가 확인되면 최종 페이지가 캐시되고 사용자는 SSG와 마찬가지로 캐시된 버전의 페이지를 받음</li>\n<li>재검증시에도 사용자는 먼저 캐시된 버전을 받고 업데이트된 버전을 받는다.</li>\n</ol>\n<p><strong>ISR 장점</strong></p>\n<ul>\n<li>SSR과 달리 페이지가 즉시 제공(fallback page), 좋은 사용자경험</li>\n</ul>\n<p><strong>ISR 단점</strong></p>\n<ul>\n<li>페이지 디자인에 따라 첫번째 의미있는 페인팅을 지연시킬 수도 있다.</li>\n</ul>\n<p><a href=\"https://velog.io/@wiostz98kr/SSR-CSR-SSG-TTV-TTI-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC\">SSR, CSR, SSG, TTV, TTI 개념 정리</a></p>","frontmatter":{"title":"CSR vs SSR vs SSG 차이 정리","date":"June 18, 2023"}}},"pageContext":{"slug":"/글또/csr-vs-ssr-vs-ssg-차이-정리/","previous":{"fields":{"slug":"/글또/javascript-this에-대해서/"},"frontmatter":{"title":"JavaScript this에 대해서"}},"next":null}}}